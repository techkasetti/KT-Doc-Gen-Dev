public class DocumentArchivalManager {
    
    // Retention policy engine
    public static void createRetentionPolicies() {
        
        List<DocumentRetentionPolicy__c> policies = new List<DocumentRetentionPolicy__c>();
        
        // GDPR-compliant retention policy
        policies.add(new DocumentRetentionPolicy__c(
            Policy_Name__c = 'GDPR_Personal_Data_Retention',
            Document_Type__c = 'DATA_PROCESSING_AGREEMENT',
            Retention_Period_Years__c = 7,
            Retention_Period_Days__c = 2555, // 7 years
            Geographic_Scope__c = 'EU;EEA',
            Legal_Basis__c = 'GDPR Article 17 - Right to Erasure',
            Auto_Delete_Enabled__c = true,
            Pre_Deletion_Review__c = true,
            Deletion_Approval_Required__c = true,
            Archive_Before_Deletion__c = true,
            Archive_Location__c = 'SECURE_CLOUD_ARCHIVE',
            Encryption_Required__c = true,
            Access_Log_Required__c = true,
            Compliance_Officer_Notification__c = true
        ));
        
        // Financial records retention
        policies.add(new DocumentRetentionPolicy__c(
            Policy_Name__c = 'Financial_Records_Retention_US',
            Document_Type__c = 'FINANCIAL_CONTRACT',
            Retention_Period_Years__c = 10,
            Retention_Period_Days__c = 3650,
            Geographic_Scope__c = 'US',
            Legal_Basis__c = 'SOX Compliance - 15 USC 7213',
            Auto_Delete_Enabled__c = false, // Manual review required
            Pre_Deletion_Review__c = true,
            Deletion_Approval_Required__c = true,
            Archive_Before_Deletion__c = true,
            Archive_Location__c = 'IMMUTABLE_BLOCKCHAIN_STORAGE',
            Encryption_Required__c = true,
            Access_Log_Required__c = true,
            Audit_Trail_Permanent__c = true
        ));
        
        // Healthcare records retention (HIPAA)
        policies.add(new DocumentRetentionPolicy__c(
            Policy_Name__c = 'HIPAA_PHI_Retention_Policy',
            Document_Type__c = 'HEALTHCARE_AGREEMENT',
            Retention_Period_Years__c = 6,
            Retention_Period_Days__c = 2190,
            Geographic_Scope__c = 'US',
            Legal_Basis__c = 'HIPAA 45 CFR 164.530(j)(2)',
            Auto_Delete_Enabled__c = false,
            Pre_Deletion_Review__c = true,
            Deletion_Approval_Required__c = true,
            Archive_Before_Deletion__c = true,
            Archive_Location__c = 'HIPAA_COMPLIANT_ARCHIVE',
            Encryption_Required__c = true,
            PHI_Anonymization_Required__c = true,
            Access_Log_Required__c = true
        ));
        
        insert policies;
        
        // Create retention schedule for each policy
        createRetentionSchedules(policies);
    }
    
    private static void createRetentionSchedules(List<DocumentRetentionPolicy__c> policies) {
        List<DocumentRetentionSchedule__c> schedules = new List<DocumentRetentionSchedule__c>();
        
        for (DocumentRetentionPolicy__c policy : policies) {
            schedules.add(new DocumentRetentionSchedule__c(
                Retention_Policy__c = policy.Id,
                Schedule_Name__c = policy.Policy_Name__c + '_Schedule',
                Execution_Frequency__c = 'MONTHLY',
                Next_Execution_Date__c = Date.today().addDays(30),
                Last_Execution_Date__c = null,
                Documents_Processed_Last_Run__c = 0,
                Documents_Archived_Last_Run__c = 0,
                Documents_Deleted_Last_Run__c = 0,
                Schedule_Status__c = 'ACTIVE',
                Notification_Recipients__c = 'compliance@company.com;legal@company.com',
                Pre_Execution_Approval_Required__c = true
            ));
        }
        
        insert schedules;
    }
    
    // Intelligent archival process
    @future(callout=true)
    public static void executeRetentionPolicy(String policyId) {
        DocumentRetentionPolicy__c policy = [
            SELECT Id, Policy_Name__c, Document_Type__c, Retention_Period_Days__c, 
                   Auto_Delete_Enabled__c, Archive_Before_Deletion__c, Archive_Location__c,
                   Encryption_Required__c, Pre_Deletion_Review__c
            FROM DocumentRetentionPolicy__c 
            WHERE Id = :policyId
        ];
        
        // Find documents eligible for archival/deletion
        Date cutoffDate = Date.today().addDays(-Integer.valueOf(policy.Retention_Period_Days__c));
        
        List<ContentDocument> documentsToProcess = [
            SELECT Id, Title, CreatedDate, ContentSize, FileType,
                   (SELECT Id, LinkedEntityId FROM ContentDocumentLinks)
            FROM ContentDocument 
            WHERE CreatedDate < :cutoffDate
            AND FileType IN ('PDF', 'DOCX', 'DOC')
        ];
        
        List<DocumentArchivalRecord__c> archivalRecords = new List<DocumentArchivalRecord__c>();
        
        for (ContentDocument doc : documentsToProcess) {
            // Create archival record
            DocumentArchivalRecord__c record = new DocumentArchivalRecord__c(
                Document_Id__c = doc.Id,
                Document_Title__c = doc.Title,
                Original_Creation_Date__c = doc.CreatedDate,
                Archival_Date__c = Date.today(),
                Retention_Policy__c = policy.Id,
                Archive_Location__c = policy.Archive_Location__c,
                File_Size_MB__c = (doc.ContentSize / 1024.0 / 1024.0),
                Encryption_Applied__c = policy.Encryption_Required__c,
                Archive_Status__c = 'PENDING_ARCHIVAL',
                Legal_Hold_Check__c = checkLegalHoldStatus(doc.Id),
                Compliance_Verification__c = 'PASSED',
                Access_History_Preserved__c = true
            );
            
            archivalRecords.add(record);
            
            // Archive document if not under legal hold
            if (!record.Legal_Hold_Check__c) {
                archiveDocument(doc, policy);
                record.Archive_Status__c = 'ARCHIVED';
                
                // Delete original if policy allows
                if (policy.Auto_Delete_Enabled__c && !policy.Pre_Deletion_Review__c) {
                    deleteOriginalDocument(doc.Id);
                    record.Original_Document_Deleted__c = true;
                }
            }
        }
        
        insert archivalRecords;
        
        // Update retention schedule
        updateRetentionScheduleStats(policyId, archivalRecords.size());
    }
    
    // private static Boolean checkLegalHoldStatus(String documentId) {
    //     Integer holdCount = [
    //         SELECT COUNT() 
    //         FROM LegalHold__c 
    //         WHERE Status__c = 'ACTIVE' 
    //         AND Document_Scope__c INCLUDES :documentId
    //     ];
    //     return holdCount > 0;
    // }
    private static Boolean checkLegalHoldStatus(String documentId) {
    Integer holdCount = [
        SELECT COUNT() 
        FROM LegalHold__c 
        WHERE Status__c = 'ACTIVE' 
        AND Document_Scope__c INCLUDES (:documentId)
    ];
    return holdCount > 0;
}

    private static void archiveDocument(ContentDocument doc, DocumentRetentionPolicy__c policy) {
        // Archive to specified location with encryption
        ArchiveService.archiveDocument(doc.Id, policy.Archive_Location__c, policy.Encryption_Required__c);
        
        // Create blockchain audit record
        BlockchainAuditManager.createImmutableAuditRecord(
            doc.Id,
            'DOCUMENT_ARCHIVED',
            'Document archived per retention policy: ' + policy.Policy_Name__c
        );
    }
    
    private static void deleteOriginalDocument(String documentId) {
        delete [SELECT Id FROM ContentDocument WHERE Id = :documentId];
    }
    
    private static void updateRetentionScheduleStats(String policyId, Integer processedCount) {
        DocumentRetentionSchedule__c schedule = [
                    SELECT Id, Documents_Processed_Last_Run__c, Last_Execution_Date__c,
               Documents_Archived_Last_Run__c, Next_Execution_Date__c
        FROM DocumentRetentionSchedule__c 
        WHERE Retention_Policy__c = :policyId 
        LIMIT 1
    ];
    
    schedule.Documents_Processed_Last_Run__c = processedCount;
    schedule.Last_Execution_Date__c = Date.today();
    schedule.Next_Execution_Date__c = Date.today().addDays(30);
    schedule.Documents_Archived_Last_Run__c = processedCount;
    
    update schedule;
}
}
