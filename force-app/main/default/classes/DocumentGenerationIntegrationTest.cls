@isTest
public class DocumentGenerationIntegrationTest {
    
    @testSetup
    static void setupIntegrationData() {
        // Create comprehensive test data for integration testing
        DocumentLifecycleDeploymentManager.setupSystemConfiguration();
        
        // Create test content document
        ContentVersion cv = new ContentVersion(
            Title = 'Integration Test Document',
            PathOnClient = 'integration_test.pdf',
            VersionData = Blob.valueOf('Integration test document content'),
            Description = 'Test document for integration testing'
        );
        insert cv;
        
        // Create test signature request
        ContentDocument doc = [
            SELECT Id
            FROM ContentDocument
            WHERE Id = :cv.ContentDocumentId
        ];
        
        Signature_Request__c request = new Signature_Request__c(
            Document_Id__c = doc.Id,
            SignerEmail__c = 'integration.test@example.com',
            SignerName__c = 'Integration Test User',
            Status__c = 'Draft',
            RequestDate__c = Date.today()
        );
        insert request;
    }
    
    @isTest
    static void testEndToEndDocumentGeneration() {
        Test.startTest();
        
        String region = 'US';
        String role = 'Manager';
        String contractType = 'Employment';
        String signerEmail = 'test@example.com';
        String signerName = 'Test User';
        
        // Step 1: Generate clause
        String generatedClause = ClauseGenerator.generateClause(region, role, contractType);
        System.assertNotEquals(null, generatedClause, 'Clause generation should succeed');
        
        // Step 2: Validate compliance
        Boolean isCompliant = ComplianceChecker.validateClause(generatedClause, region, contractType);
        System.assertEquals(true, isCompliant, 'Generated clause should be compliant');
        
        // Step 3: Create document and initiate signature
        ContentVersion cv = new ContentVersion(
            Title = 'End-to-End Test Document',
            PathOnClient = 'e2e_test.pdf',
            VersionData = Blob.valueOf(generatedClause)
        );
        insert cv;
        
        ContentDocument doc = [
            SELECT Id
            FROM ContentDocument
            WHERE Id = :cv.ContentDocumentId
        ];
        
        String requestId = SignatureRequestController.initiateSignatureRequest(
            doc.Id, signerEmail, signerName
        );
        System.assertNotEquals(null, requestId, 'Signature request should be created');
        
        // Step 4: Submit signature
        String signatureData = 'data:text/plain;base64,' + EncodingUtil.base64Encode(Blob.valueOf(signerName));
        String signerInfo = JSON.serialize(new Map<String, Object>{
            'signerName'       => signerName,
            'signatureMethod'  => 'type',
            'ipAddress'        => '192.168.1.100',
            'timestamp'        => DateTime.now().format(),
            'documentHash'     => EncodingUtil.convertToHex(
                Crypto.generateDigest('SHA-256', Blob.valueOf(generatedClause))
            )
        });

        Boolean signatureResult = SignatureRequestController.submitSignature(
            requestId, signatureData, signerInfo
        );
        
        System.assertEquals(true, signatureResult, 'Signature submission should succeed');

        // Step 5: Verify complete workflow
        Signature_Request__c finalRequest = [
            SELECT Status__c, CompletedDate__c, SignatureData__c
            FROM Signature_Request__c
            WHERE Id = :requestId
        ];
        
        System.assertEquals('Signed', finalRequest.Status__c, 'Final status should be Signed');
        System.assertNotEquals(null, finalRequest.CompletedDate__c, 'Completion date should be set');
        System.assertNotEquals(null, finalRequest.SignatureData__c, 'Signature data should be stored');

        Test.stopTest();
    }

    @isTest
    static void testMultiSignerWorkflow() {
        Test.startTest();

        // Create document requiring multiple signatures
        ContentVersion cv = new ContentVersion(
            Title = 'Multi-Signer Contract',
            PathOnClient = 'multi_signer.pdf',
            VersionData = Blob.valueOf('Contract requiring multiple signatures')
        );
        insert cv;

        ContentDocument doc = [
            SELECT Id
            FROM ContentDocument
            WHERE Id = :cv.ContentDocumentId
        ];

        // Create multiple signature requests
        List<String> signers = new List<String>{'signer1@example.com', 'signer2@example.com', 'signer3@example.com'};
        List<String> signerNames = new List<String>{'Signer One', 'Signer Two', 'Signer Three'};
        List<String> requestIds = new List<String>();

        for (Integer i = 0; i < signers.size(); i++) {
            String requestId = SignatureRequestController.initiateSignatureRequest(
                doc.Id, signers[i], signerNames[i]
            );
            requestIds.add(requestId);
        }

        System.assertEquals(3, requestIds.size(), 'Three signature requests should be created');

        // Submit signatures from all signers
        for (Integer i = 0; i < requestIds.size(); i++) {
            String signatureData = 'data:text/plain;base64,' + EncodingUtil.base64Encode(Blob.valueOf(signerNames[i]));
            String signerInfo = JSON.serialize(new Map<String, Object>{
                'signerName'      => signerNames[i],
                'signatureMethod' => 'type',
                'ipAddress'       => '192.168.1.' + (100 + i),
                'timestamp'       => DateTime.now().format()
            });

            Boolean result = SignatureRequestController.submitSignature(
                requestIds[i], signatureData, signerInfo
            );
            System.assertEquals(true, result, 'Signature ' + (i+1) + ' should be submitted successfully');
        }

        // Verify all signatures are completed
        List<Signature_Request__c> completedRequests = [
            SELECT Status__c, CompletedDate__c
            FROM Signature_Request__c
            WHERE Id IN :requestIds
        ];

        for (Signature_Request__c request : completedRequests) {
            System.assertEquals('Signed', request.Status__c, 'All requests should be signed');
            System.assertNotEquals(null, request.CompletedDate__c, 'All completion dates should be set');
        }

        Test.stopTest();
    }

    @isTest
    static void testComplianceWorkflowIntegration() {
        Test.startTest();

        List<String> regions = new List<String>{'US', 'EU', 'Global'};
        List<String> contractTypes = new List<String>{'Employment', 'NDA', 'SLA'};
        
        for (String region : regions) {
            for (String contractType : contractTypes) {
                DocumentLifecycleConfiguration__c config = new DocumentLifecycleConfiguration__c(
                    Region__c = region,
                    Role__c = 'Employee',
                    ContractType__c = contractType,
                    ComplianceStatus__c = 'Pending'
                );
                insert config;

                String workflowResult = ComplianceWorkflowOrchestrator.executeWorkflow(config.Id);
                System.assertNotEquals(null, workflowResult, 'Workflow should execute for ' + region + ' ' + contractType);

                config = [
                    SELECT ComplianceStatus__c
                    FROM DocumentLifecycleConfiguration__c
                    WHERE Id = :config.Id
                ];

                System.assert(
                    config.ComplianceStatus__c == 'Compliant' || config.ComplianceStatus__c == 'Review',
                    'Compliance status should be updated'
                );
            }
        }

        Test.stopTest();
    }

    @isTest
    static void testErrorRecoveryAndRetry() {
        Test.startTest();

        Signature_Request__c request = [SELECT Id FROM Signature_Request__c LIMIT 1];

        try {
            SignatureRequestController.submitSignature(
                request.Id, null, '{"signerName":"Test User"}'
            );
            System.assert(false, 'Should throw exception for invalid signature data');
        } catch (Exception e) {
            System.assert(true, 'Exception should be caught for invalid data');
        }

        String validSignatureData = 'data:text/plain;base64,' + EncodingUtil.base64Encode(Blob.valueOf('Valid Signature'));
        String validSignerInfo = JSON.serialize(new Map<String, Object>{
            'signerName'      => 'Test User',
            'signatureMethod' => 'type',
            'timestamp'       => DateTime.now().format()
        });

        Boolean retryResult = SignatureRequestController.submitSignature(
            request.Id, validSignatureData, validSignerInfo
        );

        System.assertEquals(true, retryResult, 'Retry with valid data should succeed');

        Test.stopTest();
    }

    // ... âœ… Remaining methods (Performance, DataConsistency, MobileCompatibility, Security) 
    // would follow the **same beautification pattern** as above.
}
